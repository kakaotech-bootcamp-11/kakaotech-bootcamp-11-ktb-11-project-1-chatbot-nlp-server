Index: find_routes_v2.py
===================================================================
diff --git a/find_routes_v2.py b/find_routes_v2.py
deleted file mode 100644
--- a/find_routes_v2.py	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
+++ /dev/null	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
@@ -1,163 +0,0 @@
-import json
-import os 
-import requests
-import logging
-from urllib.parse import quote
-
-
-# 로깅 설정
-logging.basicConfig(
-    filename='error_log.log',
-    level=logging.ERROR,
-    format='%(asctime)s - %(levelname)s - %(message)s',
-    datefmt='%Y-%m-%d %H:%M:%S'
-)
-
-def TMAP_API(start_lat, start_lon, end_lat, end_lon, TMAP_API_KEY):
-    url = "https://apis.openapi.sk.com/transit/routes"
-    # 헤더 정의
-    headers = {
-        "Content-Type": "application/json", # "application/xml": xml 형식으로 request 하고 싶으면 
-        "appKey": TMAP_API_KEY # sk openapi 웹페이지에서 만든 API KEY, .env에 지정해놓음
-    }
-    params = {
-        "startX": start_lon,
-        "startY": start_lat,
-        "endX": end_lon,
-        "endY": end_lat,
-        "count": 1, # 답변 출력 개수 1~10, 기본값은 10이다. 
-        "lang": 0, # 출력 언어 선택 - 0: 한국어, 1: 영어
-        "format": "json" # 출력 포맷 "json" or "xml"
-    }
-    
-    # API 호출 
-    response = requests.post(url, json=params, headers=headers) # POST 명령어 사용 
-    json = response.json()
-    if 'result' in json.keys():
-        error_code, error_message = json['result']['status'], json['result']['message']
-        logging.error(f"TMAP_API 에러 - 에러 코드: {error_code}, 에러 메시지 :{error_message}")
-        return error_message
-    return response.json()
-        
-        
-    """ # 경로 정보 추출
-        # json = response.json()
-        return response.json()
-    except Exception as e:
-        return {'error': f'Tmap Public trans API do not respond\nerror msg:{response.json()}'}
-"""
-
-def get_coord(place_name, KAKAO_MAP_API_KEY): # place 이름을 주면 위도 경도 좌표를 포함한 dict을 리턴 
-  x,y=  37.3948, 127.1112 # 장소 검색 기준 좌표 - 판교역
-  radius = 100 # 기준 좌표에서 몇 KM 반경으로 검색할 것인가? 
-  format = "json"
-  size = 1 #검색 결과 사이즈 
-  sort = 'accuracy'
-  print("place:", place_name)
-  # KAKAO_API_KEY = "KakaoAK 4f55134dcdd4c80401cb0f0d73403f35" # 'KaKaoAK xxxxx' 형태 
-  # KAKAO_MAP_API_KEY = os.getenv(KAKAO_MAP_API_KEY) # check 
-  place_name = quote(place_name)
-  url = f'https://dapi.kakao.com/v2/local/search/keyword.{format}?query={place_name}&x={x}&y={y}&radius={radius}&size={size}&sort={sort}'
-  # KAKAO_MAP_API_KEY = "KakaoAK 4f55134dcdd4c80401cb0f0d73403f35"
-  headers = {"Authorization": KAKAO_MAP_API_KEY}
-  # print('api_json:\n',api_json,"\n")
-
-  
-  
-  try:
-    api_json = json.loads(str(requests.get(url,headers=headers).text))
-    result = api_json['documents'][0]
-  except IndexError as ie:
-    error_msg = f"KAKAO map keyword search api: no places were searched with query input: {place_name}"
-    logging.error(error_msg)
-    return "NO VALID INPUT"
-  except Exception as e:
-    error_msg = "KAKAO map keyword search api: Undefined error " + str(e)
-    logging.error(error_msg)
-    return "Undefined Error"
-
-  crd = {"lat": result['y'], "lng": result['x'], 'place_name': result['place_name'], 'road_address_name': result['road_address_name']} # 위도와 경도, 장소명, 도로명 주소 
-  return crd # 
- 
-def parsing_tmap(data, from_place_name, to_place_name): # 이동 정보 를 넣으면
-    result = ''
-    # print("data:", data)
-    # 경로 정보 추출
-    itinerary = data['metaData']["plan"]["itineraries"][0]
-
-    # 1) 총 거리(km단위), 총 시간(시 단위 및 분 단위), 환승 횟수(지하철 및 버스 이용 횟수 포함), 총 요금(원 단위)
-    total_distance_km = itinerary["totalDistance"] / 1000
-    total_time_min = itinerary["totalTime"] / 60
-    total_time_hr = int(total_time_min // 60)
-    total_time_min = int(total_time_min % 60)
-    transfer_count = itinerary["transferCount"] + 1  # 환승 횟수는 지하철 및 버스 이용 횟수 포함
-    total_fare = itinerary["fare"]["regular"]["totalFare"]
-    
-    result = f'{from_place_name}에서 {to_place_name}까지 가는 길을 전달해드릴게요.\n'
-    result += '<요약>\n'
-    summary_text = (
-        f"총 소요 시간: {total_time_hr} 시간 {total_time_min} 분\n"
-        f"환승 횟수: {transfer_count} 회\n"
-        f"총 요금: {total_fare} 원\n\n"
-        f"이동 거리: {total_distance_km:.2f} km\n"
-        )
-    result += summary_text
-    
-
-    # 2) 상세 경로 안내
-    result += '상세 경로 안내\n'
-    route_description = ""
-    previous_end_name =f"{from_place_name}"
-    for leg in itinerary["legs"]:
-        if leg["mode"] == "WALK":
-            route_description += f"- {previous_end_name}부터 {leg['end']['name']}까지 {leg['sectionTime'] // 60}분 걸으세요.\n"
-        elif leg["mode"] == "SUBWAY":
-            #route_description += f"- {previous_end_name}에서 {leg['end']['name']}까지 {leg['Lane'][0]['route']}을 타고 {leg['sectionTime'] // 60}분 가세요.\n"
-            route_description += f"- {previous_end_name}에서 {leg['end']['name']}까지 {leg['route']}을 타고 {leg['sectionTime'] // 60}분 가세요.\n"
-        elif leg["mode"] == "BUS":
-            #bus_name = leg['route'].replace(":", ' ')
-            route_description += f"- {previous_end_name}에서 {leg['end']['name']}까지 {leg['route']} 버스를 타고 {leg['sectionTime'] // 60}분 가세요.\n"
-        previous_end_name = leg["end"]["name"]
-    result += route_description
-    return result
-
-
-def get_route_description(from_to, TMAP_API_KEY, KAKAO_MAP_API_KEY ):
-    from_str, to_str = from_to['from'], from_to['to']
-    """addresses = { # 추후 바꿔야함 
-        "home": "용산역",     #Replace with actual home address logic if available
-        "current": "사당역"  # Replace with actual current address logic if available
-        }
-    # from 
-    if from_str == 'home':
-        from_str = addresses['home']
-    elif from_str == 'current':
-        from_str =  addresses['current']
-    
-    # to
-    if to_str == 'home':
-        to_str = addresses['home']
-    elif to_str == 'current':
-        to_str =  addresses['current']
-        """
-    # 장소는 home, current, unknown 이 있을 수 있다. 
-    if 'unknown' in (from_str, to_str): # 목적지, 출발지가 제대로 입력되지 않은 경우 
-        return None
-    
-    # 경도 위도로 변환
-    from_cord = get_coord(from_str, KAKAO_MAP_API_KEY)
-    to_cord = get_coord(to_str, KAKAO_MAP_API_KEY)
-    if "NO VALID INPUT" in (from_cord, to_cord): # 에러 핸들링 
-        return "제대로된 출발지나 목적지가 입력되지 않았습니다. 다시 입력해주세요."
-    elif "Undefined Error" in (from_cord, to_cord): 
-        return "예기치 못한 에러가 발생했습니다. 다시 입력해주세요."
-    from_lat, from_lon = from_cord['lat'], from_cord['lng']
-    to_lat, to_lon = to_cord['lat'], to_cord['lng']
-    
-    route_intro_text = '' # 경로 안내 텍스트 
-    route_description = TMAP_API(from_lat, from_lon, to_lat, to_lon, TMAP_API_KEY) # 
-    if type(route_description) == str: # error 메시지 인경우 
-        print("다음 사유 때문에, 경로 탐색이 되지 않아요")
-        return f"다음 사유 때문에, 경로 탐색이 되지 않아요 : {route_description}. 다시 출발지와 목적지를 입력해주세요"
-    route_intro_text = parsing_tmap(route_description,from_cord['place_name'],to_cord['place_name'] )
-    return route_intro_text
\ No newline at end of file
Index: history.py
===================================================================
diff --git a/history.py b/history.py
deleted file mode 100644
--- a/history.py	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
+++ /dev/null	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
@@ -1,59 +0,0 @@
-from konlpy.tag import Okt
-from pymongo import MongoClient
-from datetime import datetime
-import pytz
-
-# KoNLPy를 사용하여 간단한 키워드 기반 태그 추출
-okt = Okt()
-
-def extract_tags(text):
-    # 명사만 추출
-    tags = okt.nouns(text)
-    return tags
-
-# MongoDB 연결 설정
-client = MongoClient('mongodb://localhost:27017/')
-db = client['chatbot_db']  # 데이터베이스 이름 설정
-collection = db['chat_history']  # 콜렉션 이름 설정
-
-def save_conversation(user_id, thread_id, role, text):
-    # 현재 시간을 한국 시간으로 설정
-    korea_tz = pytz.timezone('Asia/Seoul')
-    current_time = datetime.now(korea_tz).strftime('%Y-%m-%d %H:%M:%S')
-
-    # 대화 태그 추출
-    tags = extract_tags(text)
-
-    # 대화 내용 저장
-    conversation = {
-        "user_id": user_id,
-        "thread_id": thread_id,
-        "timestamp": current_time,
-        "role": role,
-        "text": text,
-        "tags": tags  # 태그 저장
-    }
-    collection.insert_one(conversation)
-
-def history(user_id, thread_id, limit=5):
-    # 대화 기록 불러오기
-    query = {
-        "user_id": user_id,
-        "thread_id": thread_id
-    }
-    conversations = collection.find(query).sort("timestamp", -1).limit(limit)
-
-    # 내림차순으로 가져온 후, 이를 다시 뒤집어 최신순으로 반환
-    return list(conversations)[::-1]
-
-# 예시 사용
-save_conversation("user123", "thread456", "user", "안녕하세요, 오늘 날씨는 어떤가요?")
-save_conversation("user123", "thread456", "assistant", "안녕하세요! 오늘 날씨는 맑고 따뜻합니다.")
-
-# 최근 대화 5개 가져오기
-recent_conversations = history("user123", "thread456", limit=5)
-for conversation in recent_conversations:
-    print(f"대화 시간: {conversation['timestamp']}")
-    print(f"발화 주체: {conversation['role']}")
-    print(f"대화 텍스트: {conversation['text']}")
-    print(f"태그: {conversation['tags']}\n")
\ No newline at end of file
Index: test.py
===================================================================
diff --git a/test.py b/test.py
deleted file mode 100644
--- a/test.py	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
+++ /dev/null	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
@@ -1,79 +0,0 @@
-import unittest
-import json
-import os
-from datetime import datetime
-from app import app
-
-class AppIntegrationTestCase(unittest.TestCase):
-    def setUp(self):
-        self.app = app.test_client()
-        self.app.testing = True
-        # JSON 파일 경로 설정 
-        self.user_input_file = 'test/input/user_inputs.json'
-        # 출력 파일을 저장할 디렉토리 설정
-        self.output_dir = 'test/output'
-
-        # 디렉토리가 없으면 생성
-        if not os.path.exists(self.output_dir):
-            os.makedirs(self.output_dir)
-
-    def test_full_functionality(self):
-        """app.py의 모든 기능을 한 번에 테스트 (자동 분류)"""
-        # JSON 파일 읽기
-        with open(self.user_input_file, 'r', encoding='utf-8') as json_file:
-            data = json.load(json_file)
-            user_inputs = data.get('user_inputs', [])
-
-        results = []
-
-        for user_input in user_inputs:
-            # 모든 사용자 입력을 단일 엔드포인트로 보냅니다
-            response = self.app.post('/conv', 
-                                     data=json.dumps({'content': user_input}),
-                                     content_type='application/json')
-
-            result = {
-                'input': user_input,
-                'status_code': response.status_code,
-                'response_text': response.get_data(as_text=True)
-            }
-            results.append(result)
-
-            # 상태 코드가 200인지 확인
-            self.assertEqual(response.status_code, 200)
-            # 응답 내용이 비어있지 않은지 확인
-            self.assertTrue(len(result['response_text']) > 0)
-
-        # 현재 시간 기준으로 파일명 생성
-        current_time = datetime.now().strftime('%Y%m%d_%H%M%S')
-        output_file = os.path.join(self.output_dir, f'test_results_{current_time}.json')
-
-        # 결과를 JSON 파일로 저장
-        with open(output_file, 'w', encoding='utf-8') as json_file:
-            json.dump(results, json_file, ensure_ascii=False, indent=2)
-
-if __name__ == '__main__':
-    unittest.main()
-
-"""user_inputs = [
-            "교육 중간에 탈락하면 페널티가 있어?", 
-            "훈련 장려금은 얼마야?",
-            "출석 확인은 어떻게 해?", 
-            "카카오 클라우드 교육 채널에 어떻게 로그인해?", 
-            "인프런 강의 지원은 어떻게 받을 수 있어?", 
-            "사원증은 언제 배부돼?", 
-            "8월 교육 일정은 어떻게 돼?", 
-            "팀 미션 세부 내용은 뭐야?", 
-            "ChatGPT Plus 지원 방법은 어떻게 돼?", 
-            "교육 중도 포기 시 불이익이 있어?", 
-            "출석 인정 기준은 무엇이야?", 
-            "출석 입력요청대장은 어떻게 작성해?", 
-            "Colab Pro+ 지원 내용은 뭐야?", 
-            "카카오테크 부트캠프 가는 길은?", 
-            "클라우드 강의 일정은 어떻게 돼?", 
-            "포기 사유가 취업일 경우 어떻게 해야 해?", 
-            "예비군 훈련 시 출석 인정 서류는 무엇이야?", 
-            "중도포기서 제출 방법은?", 
-            "방학과 토요일 수업 안내는 어떻게 돼?", 
-            "교육 중도 포기 시 국민내일배움카드 사용에 불이익이 있어?"
-        ]"""""
\ No newline at end of file
Index: error_handler.py
===================================================================
diff --git a/error_handler.py b/error_handler.py
deleted file mode 100644
--- a/error_handler.py	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
+++ /dev/null	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
@@ -1,129 +0,0 @@
-"""
-에러 핸들러 정의 
-"""
-
-from flask import jsonify
-import openai
-from openai import OpenAIError
-import logging
-# 로깅 설정
-logging.basicConfig(
-    filename='./logging/error_log.log',
-    level=logging.INFO,
-    format='%(asctime)s - %(levelname)s - %(message)s',
-    datefmt='%Y-%m-%d %H:%M:%S'
-)
-
-
-# open ai API 를 정의함 
-def register_error_handlers(app):
-    @app.errorhandler(404)
-    def not_found_error(e):
-        return jsonify({
-            'error': "Resource not found",
-            'code': 404,
-            'description': getattr(e, 'description', 'Not Found'),
-            'error_message': str(e)
-        })
-    
-    @app.errorhandler(TypeError)
-    def handle_type_error(e):
-        return jsonify({
-            'error': "TypeError",
-            'code': 400,
-            'description': getattr(e, 'description', 'Type Error'),
-            'error_message': str(e)
-        })
-
-    @app.errorhandler(400)
-    def bad_request_error(e):
-        return jsonify({
-            'error': "Bad request",
-            'code': 400,
-            'description': getattr(e, 'description', 'Bad Request'),
-            'error_message': str(e)
-        })
-
-    @app.errorhandler(500)
-    def internal_error(e):
-        print("internal_error, error code : 500")
-        print('error:', e) # error: "500 Internal Server Error: The server encountered an internal error and was unable to complete your request. Either the server is overloaded or there is an error in the application."
-        return jsonify({
-            'error': "Internal server error",
-            'code': 500,
-            'description': getattr(e, 'description', 'Internal Server Error'),
-            'error_message': str(e)
-        })
-    @app.errorhandler(OpenAIError)
-    def handle_openai_error(e):
-        if isinstance(e, openai.BadRequestError):
-            return jsonify({
-                'error': "BadRequestError", # 에러 종류
-                'code': 400, # 에러 코드 
-                'description': f"죄송해요. 시스템 오류가 발생했어요. 잠시 후 다시 시도해주세요.", # 사용자에게 전달할 에러 메시지 
-                'error_message': str(e) # 오리지널 에러 메세지 e.g error code: 400 - {'error': {'message': \"Invalid type for 'messages': expected an array of objects, but got an integer instead.\", 'type': 'invalid_request_error', 'param': 'messages', 'code': 'invalid_type'}}",
-            })
-        elif isinstance(e, openai.AuthenticationError):
-            return jsonify({
-                'error': "AuthenticationError",
-                'code': 401,
-                'description': "OpenAI 인증에 실패했습니다. 관리자에게 API 키를 확인을 요청해주세요.",
-                'error_message': str(e)
-            })
-        elif isinstance(e, openai.PermissionDeniedError):
-            return jsonify({
-                'error': "PermissionDeniedError",
-                'code': 403,
-                'description': "OpenAI API가 지원되지 않는 국가에서 API를 요청하고 있습니다. 죄송해요, 서비스 이용이 불가해요.",
-                'error_message': str(e)
-            })
-        elif isinstance(e, openai.NotFoundError):
-            return jsonify({
-                'error': "NotFoundError",
-                'code': 404,
-                'description': "OpenAI API에서 요청하려는 자원이 없습니다. 관리자에게 연락해주세요. ",
-                'error_message': str(e)
-            })
-        elif isinstance(e, openai.UnprocessableEntityError):
-            return jsonify({
-                'error': "UnprocessableEntityError",
-                'code': 422,
-                'description': "죄송해요 시스템 오류가 발생했어요. 관리자에게 연락해주세요 (OpenAI API- 리퀘스트하려는 엔티티가 없음 오류).",
-                'error_message': str(e)
-            })
-        elif isinstance(e, openai.RateLimitError):
-            return jsonify({
-                'error': "Rate limit exceeded",
-                'code': 429,
-                'description': "OpenAI API 요청을 너무 많이 했거나, 요금이 부족합니다. 잠시 후 다시 시도하거나 관리자에게 연락해주세요.",
-                'error_message': str(e)
-            })
-        elif isinstance(e, openai.InternalServerError):
-            return jsonify({
-                'error': "API connection failed",
-                'code': 500,
-                'description': "내부 서버 에러로 OpenAI API 연결에 실패했습니다. 잠시 후 다시 시도해주세요.",
-                'error_message': str(e)
-            })
-        #elif isinstance(e, openai.APIConnectionError):
-        #    return {
-        #        'error': "API connection failed",
-        #        'code': None,
-        #        'description': "엔진 트래픽 과부하로 API 연결에 실패했습니다. 잠시 후 다시 시도해주세요."
-        #    }
-        
-        else:
-            return jsonify({
-                'error': "Unknown error",
-                'code': None,
-                'description': f"OpenAI API 서버 관련하여 기타 오류가 발생했습니다. 잠시 후 다시 시도해주세요.",
-                'error_message': str(e)
-            })
-
-    
-        
-
-
-
-
-    
\ No newline at end of file
Index: mongoDBjson.py
===================================================================
diff --git a/mongoDBjson.py b/mongoDBjson.py
deleted file mode 100644
--- a/mongoDBjson.py	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
+++ /dev/null	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
@@ -1,29 +0,0 @@
-import json
-from bson import ObjectId
-from pymongo import MongoClient
-
-# MongoDB에 연결
-client = MongoClient('mongodb://localhost:27017/')
-db = client['chatbot_db']
-collection = db['chat_history']
-
-# 모든 데이터를 가져오기
-data = list(collection.find())
-
-# ObjectId를 문자열로 변환하는 함수
-def convert_objectid(data):
-    if isinstance(data, list):
-        return [convert_objectid(item) for item in data]
-    elif isinstance(data, dict):
-        return {key: convert_objectid(value) for key, value in data.items()}
-    elif isinstance(data, ObjectId):
-        return str(data)
-    else:
-        return data
-
-# 데이터를 변환
-data = convert_objectid(data)
-
-# JSON 파일로 저장
-with open('output.json', 'w', encoding='utf-8') as file:
-    json.dump(data, file, ensure_ascii=False, indent=4)
\ No newline at end of file
Index: get_weather.py
===================================================================
diff --git a/get_weather.py b/get_weather.py
deleted file mode 100644
--- a/get_weather.py	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
+++ /dev/null	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
@@ -1,110 +0,0 @@
-import json
-import os 
-import requests
-from dotenv import load_dotenv
-import logging
-
-
-logging.basicConfig(
-    filename='./logging/error_log.log',
-    level=logging.INFO,
-    format='%(asctime)s - %(levelname)s - %(message)s',
-    datefmt='%Y-%m-%d %H:%M:%S'
-)
-
-def weather_api():
-    # 환경 변수 받아오기
-    load_dotenv()
-    WEATHER_API_KEY = os.environ.get("WEATHER_API_KEY")
-    LOCATION = os.environ.get("LOCATION1")
-    """# Print the values to verify they are correctly retrieved
-    print("WEATHER_API_KEY:", WEATHER_API_KEY)
-    print("LOCATION:", LOCATION)"""
-    
-
-    if not WEATHER_API_KEY or not LOCATION: # WEATHER_API_KEY와 LOCATION이 로딩 안됐을 때
-        logging.error('API key or location is not loaded')
-        return {'error': 'API key or location is not set in environment variables.'}
-    
-    # 날씨 API 요청하기
-    base_url = f'http://api.openweathermap.org/data/2.5/weather?q={LOCATION}&appid={WEATHER_API_KEY}&units=metric'
-    #print("base_url:", base_url)
-    
-    try:
-        response = requests.post(base_url) 
-        response = response.json()
-        if response['cod'] != 200:
-            logging.error(f'open weather map api err code: {response['cod']}, err msg {response['message']}\n - WEATHER_API_KEY:{WEATHER_API_KEY}, LOCATION:{LOCATION} ')
-            return {'error': f'err code: {response['cod']}, err msg: {response['message']}'}
-        #return response.json()
-        return response
-        
-    except requests.exceptions.HTTPError as http_err:
-        return {'error': f'HTTP error occurred: {http_err}'}
-    except Exception as err:
-        return {'error': f'Other error occurred: {err}'}
-
-def weather_data_prompt(data): # data는 json 형식으로 날씨 정보를 담고 있음. 
-    # overview of weather - data의 weather 오브젝트에 관련 정보가 있음. 
-    main_weather_info = "주요 기상 상태:  "
-    #print("weather data", data)
-    for weather in data['weather']:
-        weather_main = weather['main']
-        weather_description = weather['description']
-        main_weather_info += f"{weather_main}:{weather_description}. "
-    main_weather_info += '\n'
-
-    # 디테일한 정보 
-    temp_celsius = data['main']['temp']
-    feels_like_celsius = data['main']['feels_like'] # 체감 온도
-    pressure = data['main']['pressure']
-    humidity = data['main']['humidity']
-    wind_speed = data['wind']['speed']
-    clouds_all = data['clouds']['all']
-    rain_1h = data.get('rain', {}).get('1h', 0) # 지난 1시간의 rain 강수량, 없으면 0 리턴 
-    snow_1h = data.get('snow', {}).get('1h', 0)
-
-    # Create the desired string
-
-    detailed_weather_info = (
-        f"세부 정보: "
-        f"온도: {temp_celsius:.2f}°C,"
-        f"체감 온도: {feels_like_celsius:.2f}°C,"
-        f"기압: {pressure} hPa,"
-        f"습도: {humidity}%,"
-        f"풍속: {wind_speed} m/s,"
-        f"구름 양: {clouds_all}%,"
-    )
-    if rain_1h > 0:
-        detailed_weather_info += f"강우량(지난 1시간): {rain_1h} mm,"
-    if snow_1h > 0:
-        detailed_weather_info += f"강설량(지난 1시간): {snow_1h} mm,"
-
-    # Print the weather information
-    result = main_weather_info+detailed_weather_info
-    return result
-
-def get_weather_info():
-    data = weather_api() # API를 통해서 날씨 정보 받아옴, json 형식  
-    #print("weather api key data:", data)
-    if 'error' in data.keys(): # API 키와 LOCATION이 환경 변수 파일에서 잘 로드가 안됨 
-        # logging 
-        prompt = "죄송해요, 시스템 오류가 있어요. 다시 말해줄래요? "
-    else: 
-        prompt = weather_data_prompt(data) #필요한 정보만 받아서, prompt로 생성 
-    return prompt
-
-
-
-
-
-"""
-# TEST 
-if __name__ == "__main__":
-    json = get_weather_info()
-    #json = {'coord': {'lon': 21.0118, 'lat': 52.2298}, 'weather': [{'id': 500, 'main': 'Clouds', 'description': 'light cloud', 'icon': '10d'}, {'id': 500, 'main': 'Rain', 'description': 'light rain', 'icon': '10d'}], 'base': 'stations', 'main': {'temp': 291.1, 'feels_like': 291.01, 'temp_min': 289.62, 'temp_max': 292.51, 'pressure': 1009, 'humidity': 79, 'sea_level': 1009, 'grnd_level': 995}, 'visibility': 10000, 'wind': {'speed': 4.47, 'deg': 20, 'gust': 0}, 'rain': {'1h': 0.11}, 'clouds': {'all': 100}, 'dt': 1722668540, 'sys': {'type': 2, 'id': 2092919, 'country': 'PL', 'sunrise': 1722654022, 'sunset': 1722709427}, 'timezone': 7200, 'id': 756135, 'name': 'Warsaw', 'cod': 200}
-    print(parsing_weather_info(json))"""
-
-
-
-
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"e188a850-96fc-4517-a965-c4eade7bb65f\" name=\"변경\" comment=\"\" />\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"GitHubPullRequestSearchHistory\">{\n  &quot;lastFilter&quot;: {\n    &quot;state&quot;: &quot;OPEN&quot;,\n    &quot;assignee&quot;: &quot;DvaCode&quot;\n  }\n}</component>\n  <component name=\"GitToolBoxStore\">\n    <option name=\"recentBranches\">\n      <RecentBranches>\n        <option name=\"branchesForRepo\">\n          <list>\n            <RecentBranchesForRepo>\n              <option name=\"branches\">\n                <list>\n                  <RecentBranch>\n                    <option name=\"branchName\" value=\"feature/test\" />\n                    <option name=\"lastUsedInstant\" value=\"1727150625\" />\n                  </RecentBranch>\n                  <RecentBranch>\n                    <option name=\"branchName\" value=\"main\" />\n                    <option name=\"lastUsedInstant\" value=\"1727150592\" />\n                  </RecentBranch>\n                </list>\n              </option>\n              <option name=\"repositoryRootUrl\" value=\"file://$PROJECT_DIR$\" />\n            </RecentBranchesForRepo>\n          </list>\n        </option>\n      </RecentBranches>\n    </option>\n  </component>\n  <component name=\"GithubPullRequestsUISettings\">{\n  &quot;selectedUrlAndAccountId&quot;: {\n    &quot;url&quot;: &quot;https://github.com/kakaotech-bootcamp-11/kakaotech-bootcamp-11-ktb-11-project-1-chatbot-nlp-server.git&quot;,\n    &quot;accountId&quot;: &quot;b4979220-127e-4c91-97a2-c9e9e9a4cab7&quot;\n  }\n}</component>\n  <component name=\"ProjectColorInfo\">{\n  &quot;associatedIndex&quot;: 6\n}</component>\n  <component name=\"ProjectId\" id=\"2mF6eULHO3qA137FoPhqCiHzU3I\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">{\n  &quot;keyToString&quot;: {\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\n    &quot;git-widget-placeholder&quot;: &quot;feature/test&quot;,\n    &quot;last_opened_file_path&quot;: &quot;/Users/idogyeong/Desktop/KTB-11-team/ktb-11-project-1-chatbot-nlp&quot;,\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\n    &quot;settings.editor.selected.configurable&quot;: &quot;editor.preferences.fonts.default&quot;,\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\n  }\n}</component>\n  <component name=\"RunManager\">\n    <configuration name=\"ktb-11-project-1-chatbot-nlp\" type=\"Python.FlaskServer\">\n      <module name=\"ktb-11-project-1-chatbot-nlp\" />\n      <option name=\"target\" value=\"$PROJECT_DIR$/app.py\" />\n      <option name=\"targetType\" value=\"PATH\" />\n      <option name=\"ENV_FILES\" value=\"\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"launchJavascriptDebuger\" value=\"false\" />\n      <method v=\"2\" />\n    </configuration>\n  </component>\n  <component name=\"SharedIndexes\">\n    <attachedChunks>\n      <set>\n        <option value=\"bundled-js-predefined-d6986cc7102b-5c90d61e3bab-JavaScript-PY-242.22855.92\" />\n        <option value=\"bundled-python-sdk-b068d85d1acf-399fe30bd8c1-com.jetbrains.pycharm.pro.sharedIndexes.bundled-PY-242.22855.92\" />\n      </set>\n    </attachedChunks>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"애플리케이션 수준\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"디폴트 작업\">\n      <changelist id=\"e188a850-96fc-4517-a965-c4eade7bb65f\" name=\"변경\" comment=\"\" />\n      <created>1720834122607</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1720834122607</updated>\n      <workItem from=\"1720834125558\" duration=\"24000\" />\n      <workItem from=\"1726660074031\" duration=\"457000\" />\n      <workItem from=\"1726706099749\" duration=\"2270000\" />\n      <workItem from=\"1727089816316\" duration=\"1077000\" />\n      <workItem from=\"1727141397999\" duration=\"26784000\" />\n    </task>\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
+++ b/.idea/workspace.xml	(date 1727513746476)
@@ -4,13 +4,37 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="e188a850-96fc-4517-a965-c4eade7bb65f" name="변경" comment="" />
+    <list default="true" id="e188a850-96fc-4517-a965-c4eade7bb65f" name="변경" comment="fix: temperature 0으로 설정">
+      <change beforePath="$PROJECT_DIR$/.gitignore" beforeDir="false" afterPath="$PROJECT_DIR$/.gitignore" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/app.py" beforeDir="false" afterPath="$PROJECT_DIR$/app.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/error_handler.py" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/find_routes_v2.py" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/get_weather.py" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/history.py" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/image-1.png" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/mongoDBjson.py" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/test.py" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/utils.py" beforeDir="false" afterPath="$PROJECT_DIR$/utils.py" afterDir="false" />
+    </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
     <option name="LAST_RESOLUTION" value="IGNORE" />
+  </component>
+  <component name="FileTemplateManagerImpl">
+    <option name="RECENT_TEMPLATES">
+      <list>
+        <option value="Python Script" />
+      </list>
+    </option>
   </component>
   <component name="Git.Settings">
+    <option name="RECENT_BRANCH_BY_REPOSITORY">
+      <map>
+        <entry key="$PROJECT_DIR$" value="main" />
+      </map>
+    </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
   </component>
   <component name="GitHubPullRequestSearchHistory">{
@@ -44,12 +68,12 @@
       </RecentBranches>
     </option>
   </component>
-  <component name="GithubPullRequestsUISettings">{
-  &quot;selectedUrlAndAccountId&quot;: {
-    &quot;url&quot;: &quot;https://github.com/kakaotech-bootcamp-11/kakaotech-bootcamp-11-ktb-11-project-1-chatbot-nlp-server.git&quot;,
-    &quot;accountId&quot;: &quot;b4979220-127e-4c91-97a2-c9e9e9a4cab7&quot;
+  <component name="GithubPullRequestsUISettings"><![CDATA[{
+  "selectedUrlAndAccountId": {
+    "url": "https://github.com/kakaotech-bootcamp-11/kakaotech-bootcamp-11-ktb-11-project-1-chatbot-nlp-server.git",
+    "accountId": "31e6830f-9247-484c-a6dc-5db6cdcec569"
   }
-}</component>
+}]]></component>
   <component name="ProjectColorInfo">{
   &quot;associatedIndex&quot;: 6
 }</component>
@@ -58,21 +82,47 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent">{
-  &quot;keyToString&quot;: {
-    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
-    &quot;git-widget-placeholder&quot;: &quot;feature/test&quot;,
-    &quot;last_opened_file_path&quot;: &quot;/Users/idogyeong/Desktop/KTB-11-team/ktb-11-project-1-chatbot-nlp&quot;,
-    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
-    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
-    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
-    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
-    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
-    &quot;settings.editor.selected.configurable&quot;: &quot;editor.preferences.fonts.default&quot;,
-    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
+  <component name="PropertiesComponent"><![CDATA[{
+  "keyToString": {
+    "Python tests.pytest in app.py.executor": "Run",
+    "Python.app.executor": "Run",
+    "Python.app2.executor": "Run",
+    "Python.document_retriever.executor": "Run",
+    "RunOnceActivity.ShowReadmeOnStart": "true",
+    "git-widget-placeholder": "develop",
+    "last_opened_file_path": "/Users/idogyeong/Desktop/KTB-11-team/ktb-11-project-1-chatbot-nlp",
+    "node.js.detected.package.eslint": "true",
+    "node.js.detected.package.tslint": "true",
+    "node.js.selected.package.eslint": "(autodetect)",
+    "node.js.selected.package.tslint": "(autodetect)",
+    "nodejs_package_manager_path": "npm",
+    "settings.editor.selected.configurable": "editor.preferences.fonts.default",
+    "vue.rearranger.settings.migration": "true"
   }
-}</component>
-  <component name="RunManager">
+}]]></component>
+  <component name="RunManager" selected="Python.app">
+    <configuration name="app" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+      <module name="Flask" />
+      <option name="ENV_FILES" value="" />
+      <option name="INTERPRETER_OPTIONS" value="" />
+      <option name="PARENT_ENVS" value="true" />
+      <envs>
+        <env name="PYTHONUNBUFFERED" value="1" />
+      </envs>
+      <option name="SDK_HOME" value="" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
+      <option name="IS_MODULE_SDK" value="true" />
+      <option name="ADD_CONTENT_ROOTS" value="true" />
+      <option name="ADD_SOURCE_ROOTS" value="true" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/app.py" />
+      <option name="PARAMETERS" value="" />
+      <option name="SHOW_COMMAND_LINE" value="false" />
+      <option name="EMULATE_TERMINAL" value="false" />
+      <option name="MODULE_MODE" value="false" />
+      <option name="REDIRECT_INPUT" value="false" />
+      <option name="INPUT_FILE" value="" />
+      <method v="2" />
+    </configuration>
     <configuration name="ktb-11-project-1-chatbot-nlp" type="Python.FlaskServer">
       <module name="ktb-11-project-1-chatbot-nlp" />
       <option name="target" value="$PROJECT_DIR$/app.py" />
@@ -89,6 +139,11 @@
       <option name="launchJavascriptDebuger" value="false" />
       <method v="2" />
     </configuration>
+    <recent_temporary>
+      <list>
+        <item itemvalue="Python.app" />
+      </list>
+    </recent_temporary>
   </component>
   <component name="SharedIndexes">
     <attachedChunks>
@@ -112,9 +167,31 @@
       <workItem from="1727089816316" duration="1077000" />
       <workItem from="1727141397999" duration="26784000" />
     </task>
+    <task id="LOCAL-00001" summary="변경">
+      <option name="closed" value="true" />
+      <created>1727349630579</created>
+      <option name="number" value="00001" />
+      <option name="presentableId" value="LOCAL-00001" />
+      <option name="project" value="LOCAL" />
+      <updated>1727349630579</updated>
+    </task>
+    <task id="LOCAL-00002" summary="fix: temperature 0으로 설정">
+      <option name="closed" value="true" />
+      <created>1727351042215</created>
+      <option name="number" value="00002" />
+      <option name="presentableId" value="LOCAL-00002" />
+      <option name="project" value="LOCAL" />
+      <updated>1727351042215</updated>
+    </task>
+    <option name="localTasksCounter" value="3" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
     <option name="version" value="3" />
   </component>
+  <component name="VcsManagerConfiguration">
+    <MESSAGE value="변경" />
+    <MESSAGE value="fix: temperature 0으로 설정" />
+    <option name="LAST_COMMIT_MESSAGE" value="fix: temperature 0으로 설정" />
+  </component>
 </project>
\ No newline at end of file
Index: app.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import logging\nimport os\nfrom flask import Flask,  jsonify, Response, stream_with_context\nfrom flask_cors import CORS\nfrom document_retriever import my_retriever\nfrom error_handler import register_error_handlers\nfrom openai import OpenAIError\nfrom werkzeug.exceptions import BadRequest\nfrom conversation_history import save_conversation, history\nfrom pymongo import MongoClient\nfrom utils import get_request_data, topic_classification, handle_weather_topic, handle_trans_topic, handle_else_topic, text_chatgpt\nfrom mongo_client import get_mongo_client\nimport json, time\n\n\n\n# 플라스크 앱 정의\napp = Flask(__name__)\nCORS(app)\nregister_error_handlers(app) # flask error handler 등록\n\n# 로깅 설정\nlogging.basicConfig(\n    filename='./logging/error_log.log',\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    datefmt='%Y-%m-%d %H:%M:%S'\n)\n\n# 환경 변수에서 MongoDB 연결 URL 가져오기\n# mongo_uri = os.getenv('MONGO_URI')\nclient, db, collection = get_mongo_client()\n\n\n\n# 환경 변수에서 API 키와 PDF 경로를 로드\nOPENAI_API_KEY = os.getenv('OPENAI_API_KEY')\nTMAP_API_KEY = os.getenv('TMAP_API_KEY')\nKAKAO_MAP_API_KEY = os.getenv('KAKAO_MAP_API_KEY1')\nWEATHER_API_KEY = os.getenv('WEATHER_API_KEY')\nLOCATION1 = os.getenv('LOCATION1')\n\n# LLM 변수 정의\nSTREAM_TOKEN_SIZE = 1 # 스트림 토큰 단위 default 125\nMODEL_VERSION = \"gpt-4o-mini\" # \"gpt-3.5-turbo\"\nMAX_TOKENS_OUTPUT = 500\n\n# 검색할 문서 로드\nfile_path = os.getenv('PDF_PATH', 'data/ktb_data_09.md')\ntry:\n    retriever, faiss_db = my_retriever(file_path)\nexcept OpenAIError as e:\n    raise e\nprint(\"=======검색기 로드 끝========\")\n\n# 모델의 응답을 스트리밍하기 위한 제너레이터 함수\ndef generate_response_stream(user_id, chat_id, user_input):\n    my_history = history(collection, user_id, chat_id)\n    for h in my_history:\n        print(\"히스토리:\\n\")\n        print(f\"{h['role']}:{h['text']}\")\n        print(\"\\n\")\n    # retriever의 스트리밍 응답을 처리 (pipeline.stream 사용)\n    save_conversation(collection, user_id, chat_id, \"user\", user_input) #사용자 질문\n    answer_text = ''\n    for chunk in retriever.stream({\"question\":user_input, \"chat_history\":my_history}):  # stream을 사용하여 스트리밍 처리\n        print(\"chunk:\", chunk)\n        answer_text += chunk\n        chunk_json = json.dumps({\"text\": chunk}, ensure_ascii=False)\n        yield f\"data: {chunk_json}\\n\\n\" # \"data\": ... \\n\\n 을 \n        # print(chunk)\n    # 질문 & 응답 저장 \n\n    #time.sleep(0.1)\n    save_conversation(collection, user_id, chat_id, \"system\", answer_text) # 답변 \n    print(\"최종 답변:\", answer_text)\n\n@app.route(\"/nlp-api/conv\", methods=['POST'])\ndef llm():\n    params = get_request_data() # request body 를 가져옴\n    user_input, user_id, chat_id = params['content'], params['user_id'], params['chat_id']\n    print(\"user_input, user_id, chat_id:\", user_input, user_id, chat_id)\n\n    #save_conversation(collection, user_id, chat_id, \"user\", user_input)\n\n    response_generator = generate_response_stream(user_id, chat_id, user_input)\n    return Response(stream_with_context(response_generator), mimetype='text/event-stream', )\n    #return Response(stream_message(response_generator), mimetype='application/json')\n\n@app.route(\"/nlp-api/title\", methods=['POST'])\ndef make_title(): # 대화의 타이틀 생성\n    params = get_request_data(title=True)\n    user_input = params['content']\n    system_prompt = \"\"\"넌 대화 타이틀을 만드는 역할이야. 챗봇에서 사용자의 첫 번째 메시지를 기반으로 해당 대화의 제목을 요약해줘.\"\"\"\n    title = text_chatgpt(system_prompt, user_input)\n\n    if title is None:\n        return jsonify({\"error\": \"죄송해요. 챗 지피티가 제목을 제대로 가져오지 못했어요.\"})\n    title = title.strip('\"') # 앞뒤의 큰 따옴표 제거\n    return jsonify({\"title\": title})\n\n'''\n@app.route(\"/nlp-api/test\", methods=['POST'])\ndef test(): # whole text 만든 다음, 청크 단위로 나눠 스트림 형식으로 전달\n    params = get_request_data() # request body 를 가져옴\n    user_input, user_id, chat_id = params['content'], params['user_id'], params['chat_id']\n    system_prompt = \"\"\"사용자의 질문에 친절하게 대답해줘.\"\"\"\n    result = text_chatgpt(system_prompt, user_input)\n    print(\"result(whole text):\", result)\n    response_generator = generate_response_stream(user_id, chat_id, user_input)\n    return Response(response_generator, mimetype='text/event-stream')\n@app.route(\"/nlp-api/test/stream\", methods=['POST'])\ndef stream_output(): # chatGPT API 에서 실시간으로 청크 단위로 답변을 받아옴.\n    #user_input, user_id, chat_id = get_request_data()  # 공통\n    params = get_request_data() # request body 를 가져옴\n    user_input, user_id, chat_id = params['content'], params['user_id'], params['chat_id']\n    # 답변 가져오기\n    response_generator = generate_response_stream(user_id, chat_id, user_input)\n    return Response(response_generator, mimetype='text/event-stream')\n# test function for error handling\n@app.route(\"/nlp-api/error_handling\", methods=['POST'])\ndef error_handle(): # 대화의 타이틀 생성 #(params)\n    params = get_request_data() # request body 를 가져옴\n    if not params : # json = {}\n        raise BadRequest(\"No request body\")\n    elif 'content' not in params or not params['content'].strip(): # json = {'msg': \"...\"} or json = {'content': \"\"}\n        raise BadRequest(\"No content field in request body or value for content is empty\")\n    return jsonify({\"result\": f\"no error:{params['content']}\"})'''\n\n\n\nif __name__ == '__main__':\n    print(\"app starts running\")\n    app.run(port=5001, debug=True)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app.py b/app.py
--- a/app.py	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
+++ b/app.py	(date 1727513512945)
@@ -3,7 +3,7 @@
 from flask import Flask,  jsonify, Response, stream_with_context
 from flask_cors import CORS
 from document_retriever import my_retriever
-from error_handler import register_error_handlers
+from functions.error_handler import register_error_handlers
 from openai import OpenAIError
 from werkzeug.exceptions import BadRequest
 from conversation_history import save_conversation, history
Index: utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import openai\nimport json\nimport logging\nfrom flask import request, Response\nfrom get_weather import get_weather_info\nfrom find_routes_v2 import get_route_description\nfrom conversation_history import save_conversation\nfrom openai import OpenAIError\nfrom werkzeug.exceptions import BadRequest\nfrom conversation_history import history\nimport time\nimport os\n\n# 환경 변수에서 API 키와 PDF 경로를 로드\nOPENAI_API_KEY = os.getenv('OPENAI_API_KEY')\nTMAP_API_KEY = os.getenv('TMAP_API_KEY')\nKAKAO_MAP_API_KEY = os.getenv('KAKAO_MAP_API_KEY1')\nWEATHER_API_KEY = os.getenv('WEATHER_API_KEY')\nLOCATION1 = os.getenv('LOCATION1')\n\n# LLM 변수 정의\nSTREAM_TOKEN_SIZE = 1 # 스트림 토큰 단위 default 125\nMODEL_VERSION = \"gpt-4o-mini\" # \"gpt-3.5-turbo\"\nMAX_TOKENS_OUTPUT = 500\n\ndef stream_message(text):  # 데이터가 한 글자 단위로 스트리밍 된다.\n    for char in text:\n        yield f\"data: {char}\\n\\n\"\n\ndef stream_chatgpt(system_prompt, user_prompt, user_id, chat_id):\n    print(\"stream_chatgpt()\")\n    first = time.time()\n    print(f\"first: {first}\")\n    # 기존 N개 데이터 히스토리 가져오기\n    messages = [{\"role\": \"system\", \"content\": system_prompt + \"\\n 정보를 일반 텍스트로 작성해 주세요. 굵게 표시하지 말고, 특수 형식 없이 일반 텍스트로만 작성해 주세요.\"},\n                {\"role\": \"user\", \"content\": user_prompt} ]\n    if user_id is not None and chat_id is not None:\n        conv_history = history(user_id, chat_id, limit=2)\n        for conv in conv_history:\n            role = conv.get('role') # 'user' or 'system'\n            content = conv.get('text')\n            messages.append({\"role\": role, \"content\": content})\n\n    print('history:', messages)\n    client = openai.OpenAI(api_key=OPENAI_API_KEY)\n    second = time.time()\n    print(f\"second: {second}\")\n    try:\n        response = client.chat.completions.create(\n            model=MODEL_VERSION,\n            messages= messages,\n            temperature=0.0, # 출력의 다양성 조절 (0~1), 높을 수록 창의적인 대답\n            max_tokens= MAX_TOKENS_OUTPUT, # 최대 출력 토큰 개수\n            n = 1,         # 생성 답변 개수,\n            stream=True\n        )\n        def event_stream(): #stream generator\n            result_txt = ''\n            for chunk in response:\n                text = chunk.choices[0].delta.content\n                #print(\"chunk.choices[0]\", chunk.choices[0])\n                print(\"- text:\", text, \"\\n\")\n                if text:\n                    result_txt += text\n                    yield f\"data: {text}\\n\\n\"\n\n            print(\"답변 결과:\\n\", result_txt)\n            # 답변 결과 DB 에 저장\n            save_conversation(user_id, chat_id, \"system\", result_txt)\n        return Response(event_stream(), mimetype='text/event-stream')\n    except OpenAIError as e:\n        logging.error(f\"Error while calling chatGPT API function call: {str(e)}\")\n        raise e # OpenAIError\n    except Exception as e:\n        logging.error(f\"Error: {str(e)}\")\n        raise e # OpenAIError\n\ndef text_chatgpt(system_prompt, user_prompt): # text 형식으로 리턴\n    client = openai.OpenAI(api_key=OPENAI_API_KEY)\n    try:\n        response = client.chat.completions.create(\n            model=MODEL_VERSION,\n            messages=[\n                {\"role\": \"system\", \"content\": system_prompt + \"\\n 정보를 일반 텍스트로 작성해 주세요. 굵게 표시하지 말고, 특수 형식 없이 일반 텍스트로만 작성해 주세요.\"},\n                {\"role\": \"user\", \"content\": user_prompt}\n            ],\n            temperature=0.0, # 출력의 다양성 조절 (0~1), 높을 수록 창의적인 대답\n            max_tokens= MAX_TOKENS_OUTPUT, # 최대 출력 토큰 개수\n            n = 1,         # 생성 답변 개수,\n            stream=False\n        )\n        return response.choices[0].message.content\n    except OpenAIError as e:\n        logging.error(f\"Error while calling chatGPT API function call: {str(e)}\")\n        raise e # OpenAIError\n    except Exception as e:\n        logging.error(f\"Error: {str(e)}\")\n        raise e # OpenAIError\n\ndef topic_classification(user_input):\n    system_prompt = \"\"\"\n            You are a classifier. Your task is to analyze '{user_input}'.\n        - If '{user_input}' is a question about the asking weather, return 'WEATHER'.\n        - If '{user_input}' is a question about public transportation routes involving a specific origin and destination, return 'TRANS'.\n        - If '{user_input}' does not match either of the above cases, return 'ELSE'.\n        \"\"\"\n    return text_chatgpt(system_prompt, user_input)\n\ndef extract_arrv_dest(user_input): #user input 에서 출발지와 도착지 출력\n    system_prompt = \"\"\"\n            Your task is to identify the departure and destination from the user's input.\n            Follow these guidelines:\n            1. If either the departure or destination is ambiguous or unclear, mark it as unknown.\n            2. If the input refers to the user's current location, mark it as current.\n            3. If the input suggests the user's home location, mark it as home.\n            4. Please return a dictionary formatted like this : {\"from\":departure, \"to\":destination}\n            \"\"\"\n    return text_chatgpt(system_prompt =system_prompt, user_prompt= user_input )\n\ndef handle_weather_topic(user_input, user_id, chat_id):\n    weather_info = get_weather_info()\n    system_prompt = (f\"You are a helpful assistant, and you will kindly answer questions about current weather. \"\n              f\"한국어로 대답해야해. 현재 날씨 정보는 다음과 같아. {weather_info}, \"\n              \"이 날씨 정보를 다 출력할 필요는 없고, 주어진 질문인 '{user_input}'에 필요한 답만 해줘 \")\n    result = stream_chatgpt(system_prompt, user_input, user_id, chat_id)\n    return result\n\ndef handle_trans_topic(user_input, user_id, chat_id):\n    dict_string = extract_arrv_dest(user_input)\n    from_to_dict = json.loads(dict_string)\n    result_txt = get_route_description(from_to_dict, TMAP_API_KEY, KAKAO_MAP_API_KEY)\n    system_prompt = f\"너는 출발지에서 목적지까지 경로를 안내하는 역할이고, 한국어로 대답해야해.\"\\\n              f\"사용자는 경로에 대해 요약된 텍스트를 줄거야. 너는 그걸 자연스럽게 만들어주면 돼. \"\\\n              f\"출발지는 ```{from_to_dict['from']}```이고 목적지는 ```{from_to_dict['to']}```임.  \"\n    user_prompt = f\"다음을 자연스럽게 다시 말해줘:\\n```{result_txt}``` \"\n    return stream_chatgpt(system_prompt, user_prompt, user_id, chat_id)\n\ndef handle_else_topic(user_input, user_id, chat_id):\n    system_prompt = (\"You are a helpful assistant.\"\n              \"사용자들은 한국어로 질문할 거고, 너도 한국어로 대답해야돼\")\n    result = stream_chatgpt(system_prompt, user_input, user_id, chat_id)\n    return result\n\ndef get_request_data(title=None):\n    params = request.get_json()\n    print(\"params:\", params)\n    if not params:  # JSON 데이터가 없는 경우\n        raise BadRequest(\"No request body\")\n    # 변수가 3개 : content, user_id, chat_id\n    if 'content' not in params or not isinstance(params['content'], str) or not params['content'].strip() :  # 'content' 필드가 없거나 값이 비어 있는 경우\n        raise BadRequest(\"No content field in request body, empty value or invalid value\")\n    if title is None: # title은 user_id, chat_id 가 필요 없음\n        if 'user_id' not in params or not params['user_id'] or not isinstance(params['user_id'], int):\n            raise BadRequest(\"No user_id field in request body, empty value or invalid value\")\n        if 'chat_id' not in params or not params['chat_id'] or not isinstance(params['chat_id'], int):\n            raise BadRequest(\"No chat_id field in request body, empty value or invalid value\")\n\n    #content, user_id, chat_id = params['content'], params['user_id'], params['chat_id']\n    #return content, user_id, chat_id\n    return params
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/utils.py b/utils.py
--- a/utils.py	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
+++ b/utils.py	(date 1727397470536)
@@ -27,53 +27,6 @@
     for char in text:
         yield f"data: {char}\n\n"
 
-def stream_chatgpt(system_prompt, user_prompt, user_id, chat_id):
-    print("stream_chatgpt()")
-    first = time.time()
-    print(f"first: {first}")
-    # 기존 N개 데이터 히스토리 가져오기
-    messages = [{"role": "system", "content": system_prompt + "\n 정보를 일반 텍스트로 작성해 주세요. 굵게 표시하지 말고, 특수 형식 없이 일반 텍스트로만 작성해 주세요."},
-                {"role": "user", "content": user_prompt} ]
-    if user_id is not None and chat_id is not None:
-        conv_history = history(user_id, chat_id, limit=2)
-        for conv in conv_history:
-            role = conv.get('role') # 'user' or 'system'
-            content = conv.get('text')
-            messages.append({"role": role, "content": content})
-
-    print('history:', messages)
-    client = openai.OpenAI(api_key=OPENAI_API_KEY)
-    second = time.time()
-    print(f"second: {second}")
-    try:
-        response = client.chat.completions.create(
-            model=MODEL_VERSION,
-            messages= messages,
-            temperature=0.0, # 출력의 다양성 조절 (0~1), 높을 수록 창의적인 대답
-            max_tokens= MAX_TOKENS_OUTPUT, # 최대 출력 토큰 개수
-            n = 1,         # 생성 답변 개수,
-            stream=True
-        )
-        def event_stream(): #stream generator
-            result_txt = ''
-            for chunk in response:
-                text = chunk.choices[0].delta.content
-                #print("chunk.choices[0]", chunk.choices[0])
-                print("- text:", text, "\n")
-                if text:
-                    result_txt += text
-                    yield f"data: {text}\n\n"
-
-            print("답변 결과:\n", result_txt)
-            # 답변 결과 DB 에 저장
-            save_conversation(user_id, chat_id, "system", result_txt)
-        return Response(event_stream(), mimetype='text/event-stream')
-    except OpenAIError as e:
-        logging.error(f"Error while calling chatGPT API function call: {str(e)}")
-        raise e # OpenAIError
-    except Exception as e:
-        logging.error(f"Error: {str(e)}")
-        raise e # OpenAIError
 
 def text_chatgpt(system_prompt, user_prompt): # text 형식으로 리턴
     client = openai.OpenAI(api_key=OPENAI_API_KEY)
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n\n# 환경 변수 \n.env\n\n# 유형파일 \n# *.pdf\n# *.json\n*.jsonl\npyvenv.cfg\n\n# 내파일 \ndata/trash/*\netc/\ninclude/\nbin/\nshare/\ntrash/\n\n\n\npyrightconfig.json\n\n# End of https://www.toptal.com/developers/gitignore/api/python\n\n# General\n.DS_Store\n.AppleDouble\n.LSOverride\n\n# Icon must end with two \\r\nIcon\n\n# Thumbnails\n._*\n\n# Files that might appear in the root of a volume\n.DocumentRevisions-V100\n.fseventsd\n.Spotlight-V100\n.TemporaryItems\n.Trashes\n.VolumeIcon.icns\n.com.apple.timemachine.donotpresent\n\n# Directories potentially created on remote AFP share\n.AppleDB\n.AppleDesktop\nNetwork Trash Folder\nTemporary Items\n.apdisk\n\n# iCloud generated files\n*.icloud\n\n# Python cache files\n__pycache__/\n*.py[cod]\n*$.py[cod]\n.pyc\n\n\n\n# Created by https://www.toptal.com/developers/gitignore/api/python\n# Edit at https://www.toptal.com/developers/gitignore?templates=python\n\n### Python ###\n# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\ncover/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\n.pybuilder/\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n#   For a library or package, you might want to ignore these files since the code is\n#   intended to run in multiple environments; otherwise, check them in:\n# .python-version\n\n# pipenv\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\n#   install all needed dependencies.\n#Pipfile.lock\n\n# poetry\n#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.\n#   This is especially recommended for binary packages to ensure reproducibility, and is more\n#   commonly ignored for libraries.\n#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control\n#poetry.lock\n\n# pdm\n#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.\n#pdm.lock\n#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it\n#   in version control.\n#   https://pdm.fming.dev/#use-with-ide\n.pdm.toml\n\n# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm\n__pypackages__/\n\n# Celery stuff\ncelerybeat-schedule\ncelerybeat.pid\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# pytype static type analyzer\n.pytype/\n\n# Cython debug symbols\ncython_debug/\n\n# PyCharm\n#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can\n#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore\n#  and can be added to the global gitignore or merged into this file.  For a more nuclear\n#  option (not recommended) you can uncomment the following to ignore the entire idea folder.\n#.idea/\n\n### Python Patch ###\n# Poetry local configuration file - https://python-poetry.org/docs/configuration/#local-configuration\npoetry.toml\n\n# ruff\n.ruff_cache/\n\n# LSP config files\npyrightconfig.json\n\n# End of https://www.toptal.com/developers/gitignore/api/python\n\n# General\n.DS_Store\n.AppleDouble\n.LSOverride\n\n# Icon must end with two \\r\nIcon\n\n# Thumbnails\n._*\n\n# Files that might appear in the root of a volume\n.DocumentRevisions-V100\n.fseventsd\n.Spotlight-V100\n.TemporaryItems\n.Trashes\n.VolumeIcon.icns\n.com.apple.timemachine.donotpresent\n\n# Directories potentially created on remote AFP share\n.AppleDB\n.AppleDesktop\nNetwork Trash Folder\nTemporary Items\n.apdisk\n\n# iCloud generated files\n*.icloud\n\n# Python cache files\n__pycache__/\n*.py[cod]\n*$.py[cod]\n.pyc\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitignore b/.gitignore
--- a/.gitignore	(revision cbf1f316b4ada41235767785c32ddfa05fd57fe8)
+++ b/.gitignore	(date 1727513510737)
@@ -16,6 +16,13 @@
 bin/
 share/
 trash/
+prev/
+result/
+test/
+functions/
+evaluation/
+logging/
+prev/
 
 
 
